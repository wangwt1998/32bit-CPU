`include "defines.v"

//对指令进行译码，得到运算类型和子类型，源操作数1和2，是否要写入寄存器和目的寄存器地址
module id(

	input wire		      rst,                //1bit，复位信号
	input wire[`InstAddrBus]      pc_i,               //32bit，取指送过来的指令的地址
	input wire[`InstBus]          inst_i,             //32bit，取指送过来的指令
        
	//输出到regfile的信息
	output reg                    reg1_read_o,        //1bit，读寄存器1的使能信号
	output reg                    reg2_read_o,        //1bit，读寄存器2的使能信号     
	output reg[`RegAddrBus]       reg1_addr_o,        //1bit，读寄存器1的地址信号
	output reg[`RegAddrBus]       reg2_addr_o,        //1bit，读寄存器2的地址信号    
	
	//读取的regflie的值
	input wire[`RegBus]           reg1_data_i,        //1bit，从寄存器1读出来的值
	input wire[`RegBus]           reg2_data_i,        //1bit，从寄存器2读出来的值	      
	
	//送到执行阶段的信息
	output reg[`AluOpBus]         aluop_o,            //8bit，译码阶段得到的运算子类型
	output reg[`AluSelBus]        alusel_o,           //3bit，译码阶段得到的运算类型
	output reg[`RegBus]           reg1_o,             //32bit，源操作数1
	output reg[`RegBus]           reg2_o,             //32bit，源操作数2
	output reg                    wreg_o              //1bit，是否有要写入的目的寄存器
	output reg[`RegAddrBus]       wd_o,               //5bit，要写入的目的寄存器地址
);

  //取得指令的指令码，功能码，
  //对于ori指令只需通过判断第26-31bit的值，即可判断是否是ori指令
  wire[5:0] op = inst_i[31:26];
  wire[4:0] op2 = inst_i[10:6];
  wire[5:0] op3 = inst_i[5:0];
  wire[4:0] op4 = inst_i[20:16];
  
  //保存指令执行需要的立即数
  reg[`RegBus]	imm;
  
  //指示指令是否有效
  reg instvalid;
  
 //////第一段：对指令进行译码//////
	always @ (*) begin	//组合逻辑电路
		if (rst == `RstEnable) begin   //复位
			aluop_o       <= `EXE_NOP_OP;            //运算子类型，复位时置0
			alusel_o      <= `EXE_RES_NOP;           //运算类型，复位时置0
			wreg_o        <= `WriteDisable;          //写入目的寄存器使能信号无效
			wd_o          <= `NOPRegAddr;            //写入目的寄存器地址置0
			instvalid     <= `InstValid;             //指令无效
			reg1_read_o   <= 1'b0;                   //读寄存器1使能信号无效
			reg2_read_o   <= 1'b0;                   //读寄存器2使能信号无效
			reg1_addr_o   <= `NOPRegAddr;            //读寄存器1地址信号置0        
			reg2_addr_o   <= `NOPRegAddr;            //读寄存器2地址信号置0      
			imm           <= 32'h0;                  //立即数置0
	        end else begin
			aluop_o       <= `EXE_NOP_OP;            //运算子类型，初始值设为0
			alusel_o      <= `EXE_RES_NOP;           //运算类型，初始值设为0
			wreg_o        <= `WriteDisable;          //写入目的寄存器使能信号，初始值设为无效
			wd_o          <= inst_i[15:11];          //写入目的寄存器地址，从指令中提出来
			instvalid     <= `InstInvalid;           //指令初始值设为无效	   
			reg1_read_o   <= 1'b0;                   //读寄存器1使能信号，初始值设为无效
			reg2_read_o   <= 1'b0;                   //读寄存器2使能信号，初始值设为无效
			reg1_addr_o   <= inst_i[25:21];          //读寄存器1地址信号，从指令中提出来
			reg2_addr_o   <= inst_i[20:16];          //读寄存器2地址信号，从指令中提出来
			imm <= `ZeroWord;		         //立即数，初始值置0
		  
		  //把上面赋初值的8个变量依据指令的不同赋上相应的值
		    case (op)
		  	`EXE_ORI:	begin                        //依据op的值判断是否为ori指令
		  		//ori指令需要将结果写入目的寄存器，所以wreg_o为WriteEnable
				wreg_o <= `WriteEnable;		
				
			        //运算的子类型是逻辑或运算
				aluop_o <= `EXE_OR_OP;
		  		
				//运算的类型是逻辑运算
				alusel_o <= `EXE_RES_LOGIC; 
				
				//需要通过regfile的读端口1读取寄存器
				reg1_read_o <= 1'b1;	
				
				//不需要通过regfile的读端口2读取寄存器
				reg2_read_o <= 1'b0;	  	
				
				//指令执行需要的立即数
				imm <= {16'h0, inst_i[15:0]};		
				
			        //指令执行要写的目的寄存器地址
				wd_o <= inst_i[20:16];
				
				//ori指令是有效指令
				instvalid <= `InstValid;	
		  	
		        end 							 
		        default:begin
		        end
		    endcase		  //case op			
		end                       //if
	end                               //always
	

//////第二段：确定进行运算的操作数1，即reg1_o//////
	always @ (*) begin    //组合逻辑电路
		if(rst == `RstEnable) begin 
			reg1_o <= `ZeroWord;               //复位时，源操作数置0
	        end else if(reg1_read_o == 1'b1) begin
	  	        reg1_o <= reg1_data_i;             //如果是读寄存器的值，就把寄存器里的值赋给源操作数
	        end else if(reg1_read_o == 1'b0) begin
	  	        reg1_o <= imm;                     //如果是指令里的值，就把立即数赋给源操作数
	        end else begin
	                reg1_o <= `ZeroWord;
	        end
	end
	
	
//////第二段：确定进行运算的操作数2，即reg2_o//////
	always @ (*) begin    //组合逻辑电路，和上面是一样的
		if(rst == `RstEnable) begin
			reg2_o <= `ZeroWord;               
	        end else if(reg2_read_o == 1'b1) begin
	  	        reg2_o <= reg2_data_i;             
	        end else if(reg2_read_o == 1'b0) begin
	  	        reg2_o <= imm;                     
	        end else begin
	                reg2_o <= `ZeroWord;
	  end
	end

endmodule
