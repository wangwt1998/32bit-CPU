`include "defines.v"

module ex(

	input wire	              rst,         //1bit，复位信号
	
	//送到执行阶段的信息
	input wire[`AluOpBus]         aluop_i,     //8bit，运算子类型
	input wire[`AluSelBus]        alusel_i,    //3bit，运算类型
	input wire[`RegBus]           reg1_i,      //32bit，源操作数1
	input wire[`RegBus]           reg2_i,      //32bit，源操作数2
	input wire[`RegAddrBus]       wd_i,        //5bit，要写入的目的寄存器地址
	input wire                    wreg_i,      //1bit，是否要写入目的寄存器

	//执行的结果
	output reg[`RegAddrBus]       wd_o,        //5bit，要写入的目的寄存器地址
	output reg                    wreg_o,      //1bit，是否要写入目的寄存器
	output reg[`RegBus]	      wdata_o      //32bit，要写入目的寄存器的值
	
);

  reg[`RegBus] logicout;     //保存逻辑运算结果
  reg[`RegBus] shiftres;     //保存移位运算结果
 
 //进行逻辑运算
 always @ (*) begin
        if(rst == `RstEnable) begin
		logicout <= `ZeroWord;
	end else begin
		case (aluop_i)  //判断运算子类型
			`EXE_OR_OP:begin   //逻辑或运算
				logicout <= reg1_i | reg2_i;
			end
			`EXE_AND_OP:begin  //逻辑与运算
				logicout <= reg1_i & reg2_i;
			end
			`EXE_NOR_OP:begin  //逻辑或非运算
				logicout <= ~(reg1_i |reg2_i);
			end
			`EXE_XOR_OP:begin  //逻辑异或运算
				logicout <= reg1_i ^ reg2_i;
			end
			default:begin
			        logicout <= `ZeroWord;
			end
		endcase
	end  //if
  end //always

always @ (*) begin
		if(rst == `RstEnable) begin
			shiftres <= `ZeroWord;
		end else begin
			case (aluop_i)
				`EXE_SLL_OP:			begin
					shiftres <= reg2_i << reg1_i[4:0] ;
				end
				`EXE_SRL_OP:		begin
					shiftres <= reg2_i >> reg1_i[4:0];
				end
				`EXE_SRA_OP:		begin
					shiftres <= ({32{reg2_i[31]}} << (6'd32-{1'b0, reg1_i[4:0]})) 
												| reg2_i >> reg1_i[4:0];
				end
				default:				begin
					shiftres <= `ZeroWord;
				end
			endcase
		end    //if
	end      //always
////////第二段：依据aluse1_i指示的运算类型，选择一个运算结果作为最终结果，此处只有逻辑运算结果//////
 always @ (*) begin
	wd_o <= wd_i;	 	 	
	wreg_o <= wreg_i;
	case ( alusel_i ) 
	 	  `EXE_RES_LOGIC:	begin
	 		   wdata_o <= logicout;  //如果运算类型时逻辑运算就把逻辑运算结果logicout赋给输出值
	 	   end
	 	   default:	        begin
	 		   wdata_o <= `ZeroWord;
	 	   end
	endcase
 end	

endmodule
